[TOC]
# 任务3：感知器与神经元

## 1 任务目标

1. 理解感知器模型

2. 从感知器引出神经元

3. 感知器的实现


## 2 任务描述

想要盖起大厦，先要打好地基。为了引出后面的神经网络，本次任务中先从感知器模型入手，抽丝剥茧，理解好神经网络的最基本单元。


## 3 知识准备


### 3.1 什么是感知器

感知器模型可以追溯到20世纪50/60年代，可以把感知器理解为一个根据不同因素、以及各个因素的重要性程度而做决策的模型。

举个例子，这周末北京有一草莓音乐节，那去不去呢？决定你是否去有二个因素，这二个因素可以对应二个输入，分别用x1、x2表示。此外，这二个因素对做决策的影响程度不一样，各自的影响程度用权重w1、w2表示。一般来说，音乐节的演唱嘉宾会非常影响你去不去，唱得好的前提下 即便没人陪同都可忍受，但如果唱得不好还不如你上台唱呢。所以，我们可以如下表示：

- x1：是否有喜欢的演唱嘉宾。x1 = 1 你喜欢这些嘉宾，x2 = 0 你不喜欢这些嘉宾。嘉宾因素的权重 w1 = 7
- x2：是否有人陪你同去。x2 = 1 有人陪你同去， x2 = 0 没人陪你同去。是否有人陪同的权重 w2 = 3。

这样，咱们的决策模型便建立起来了：g(z) = g( w1 * x1 + w2 * x1 + b )，g表示激活函数，代表你综合x1、x2这些因素后决定去还是不去，这里的b可以理解成为更好达到目标而做调整的偏置项。

看了以上例子，可以通俗地概括一下感知器模型，即一系列输入分别乘以对应的权重，求和后再加上一个常数，再送进某个函数里得出一个结果。

### 3.2 感知器的定义

![](https://ae01.alicdn.com/kf/H31315d2f9ff5430da9ca29319e3f8d41v.png)

 可以看到，一个感知器有如下组成部分：

(1) 一个感知器可以接收多个输入：

```math
x_1,x_2,···,x_n
```
(2) 每个输入上有一个权重：

```math
w_1,w_2,···,w_n
```
(3) 另外会再加上偏置 w0（经常也写成b），可以看作输入常为 1 的权重，因此可以与权重合并写成

```math
w_0,w_1,w_2,···,w_n
```
将输入和权重分别记为 1xN 和 Nx1 的矩阵**x**和**w**，则感知器可记为：



```math
f(xw + w_0)
```
### 3.3 激活函数
一开始为了简单，人们把激活函数定义成一个线性函数，即对于结果做一个线性变化，比如一个简单的线性激活函数是g(z) = z，输出都是输入的线性变换。后来实际应用中现，线性激活函数太过局限，于是人们引入了非线性激活函数。

常用的非线性激活函数有sigmoid、tanh、relu等等

Sigmoid 是常用的非线性的激活函数，它的数学形式如下：

```math
f(z) = {1 \over 1 + e^{-z}}
```
Sigmoid的几何图像如下：

![](https://ae01.alicdn.com/kf/H5d8c5854db614cdfaba5759f4a1ad047K.jpg)

特点：
它能够把输入的连续实值变换为0和1之间的输出，特别的，如果是非常大的负数，那么输出就是0；如果是非常大的正数，输出就是1。

tanh函数解析式：

```math
tanh(x)={{e^x-e^{-x}}\over{e^x+e^{-x}}}
```
tanh函数图像：

![](https://ae01.alicdn.com/kf/Ha408890938914482aa60d0ec2cf57a83O.jpg)

Relu函数的解析式：

```math
Relu=max(0,x)
```
Relu函数的图像：

![](https://ae01.alicdn.com/kf/H193a15954ebc4006a3ea4667c2a4c199X.jpg)

由其图像可以看出，当输入为负数时；当输入非负时，相当于 f(x) = x

### 3.4 感知器的训练

感知器的权重 w 和偏置 b 是如何获得适合的值？这就要提到训练。简单来说，训练就是先随机设置 w 和 b，然后给定一组正确的输入和输出，让输入通过感知器得到的输出与正确的输出作误差比较，往减小误差的方向去调整（更新） w 和 b，如此往复循环，最终使 w 和 b 逼近最优值。

从数学上可以这样表达：

```math
w_i \leftarrow w_i + \Delta w_i

b \leftarrow b + \Delta b
```
其中：

```math
\Delta w_i = \eta (t-y)x_i

\Delta b = \eta (t-y)
```

wi是与输入xi对应的权重项，b是偏置项。t是训练样本的实际值，一般称之为label。而y是感知器的输出值，它是根据具体的激活函数计算得出。η是一个称为学习速率的常数，其作用是控制每一步调整权的幅度。

每次从训练数据中取出一个样本的输入向量x，使用感知器计算其输出y，再根据上面的规则来调整权重。每处理一个样本就调整一次权重。经过多轮迭代后（即全部的训练数据被反复处理多轮），就可以训练出感知器的权重，使之实现最优的模型。

## 4 任务实施

利用感知器实现线性回归，即感知器的激活函数为 f(x) = x,可以理解为不带激活函数的感知器。这就是最简单的感知器的实现。

### 4.1 实施思路

1.利用python库初始化一组二维平面上的散点

2.初始化一个权重和一个偏置

3.构造感知器的输出与正确输出的误差函数

4.不断地减小误差（这个过程即训练）

### 4.2 实施步骤

随机生成200个点，分布在y=0.1x+0.3直线周围，并画出来，最终拟合后，w 理应趋向0.1, b 理应趋向0.3，可以在运行后验证。
```
#引入python库
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
 

vectors_set = []
for i in range(200):
    x1 = np.random.normal(0.0,0.55)
    #设置一定范围的浮动
    y1 = x1*0.1+0.3+np.random.normal(0.0,0.03)
    vectors_set.append([x1,y1])
 
x_data = [v[0] for v in vectors_set]
y_data = [v[1] for v in vectors_set]
 
plt.scatter(x_data,y_data,c='r')
plt.show()
```

初始化权重和偏置，构造感知器y = wx + b

```
#生成一维的w矩阵，取值为[-1，1]之间的随机数
w = tf.Variable(tf.random_uniform([1],-1.0,1.0),name='W')
#生成一维的b矩阵，初始值为0
b = tf.Variable(tf.zeros([1]),name='b')

y = w*x_data+b
```
构造感知器的输出与正确输出的误差函数loss
```
#均方误差
loss = tf.reduce_mean(tf.square(y-y_data),name='loss')
#这是一个误差的优化器
optimizer = tf.train.GradientDescentOptimizer(0.5)
#最小化loss
train = optimizer.minimize(loss,name='train')
```
将构造好的模型放在TensorFlow中的会话运行，并打印出每一次运行后的结果
```
sess = tf.Session()
init = tf.global_variables_initializer()
sess.run(init)
 
for step in range(20):
    sess.run(train)
    print("W=",sess.run(w),"b=",sess.run(b),"loss=",sess.run(loss))
 
#显示拟合后的直线
plt.scatter(x_data,y_data,c='r')
plt.plot(x_data,sess.run(w)*x_data+sess.run(b))
plt.show()
```
经过20次循环迭代后的结果参考

![](https://ae01.alicdn.com/kf/Hf2b07892cd0049ec87e52145c36957e24.png)

## 5 任务拓展

### 5.1 numpy

1. 准安装的Python中用列表(list)保存一组值，可以用来当作数组使用，不过由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。这样为了保存一个简单的[1,2,3]，需要有3个指针和三个整数对象。对于数值运算来说这种结构显然比较浪费内存和CPU计算时间。

2. 此外Python还提供了一个array模块，array对象和列表不同，它直接保存数值，和C语言的一维数组比较类似。但是由于它不支持多维，也没有各种运算函数，因此也不适合做数值运算。

3. 所以numpy就这么登场了，NumPy是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix））。 NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。

### 5.2 Matplotlib
Matplotlib是一个Python 2D绘图库，可以生成各种硬拷贝格式和跨平台交互式环境的出版物质量数据。Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。

Matplotlib试图让简单易事的事情成为可能。你只需几行代码即可生成绘图，直方图，功率谱，条形图，误差图，散点图等。

对于简单的绘图，pyplot模块提供类似MATLAB的接口，特别是与IPython结合使用时。 对于高级用户，你可以通过面向对象的界面或通过MATLAB用户熟悉的一组函数完全控制线型，字体属性，轴属性等。
## 6 任务实训

### 6.1 实训目的
增强对于感知器的了解，增加代码实现的熟练度

### 6.2 实训内容

利用感知器模型，对三维坐标的散点进行线性拟合。
（提示：只需增加一组权重和输入，即 y = w1x1 + w2x2 + b） 
